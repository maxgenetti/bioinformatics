#!/usr/bin/env python3
# Max Genetti (mgenetti)

'''
This program implements Baum-Welch Learning 

Main expects a file formatted for rosalind problem 23 handled by a general file
reader class FileReader.

Given: A sequence of emitted symbols x = x1 . . . xn in an alphabet A,
generated by a k-state HMM with unknown transition and emission probabilities,
initial Transition and Emission matrices and a number of iterations I.

Return: A matrix of transition probabilities Transition and a matrix of
emission probabilities Emission that maximizes Pr(x,π) over all possible
transition and emission matrices and over all hidden paths π. 
'''

import sys
import numpy as np


class FileReader :
   '''
   Args:
      fname: a file formatted with a string in each line
      
   Returns:
      The list parsed by lines starting with - into a lists containing each line between.
   '''
   
   def __init__ (self, fname='') :
      '''constructor: saves attribute fname'''
      self.fname = fname
      self.lines = []

   def doOpen (self) :
      '''opens the file'''
      if self.fname is '':
         return sys.stdin
      else:
         return open(self.fname)
 
   def readFile (self) :
      '''parses the file'''
      matrices = []
      matrix = []
      with self.doOpen() as fileH:
         for line in fileH:
            if line.startswith('-') : #seperates lists on lines starting with -
               matrices.append(matrix)
               matrix = []
               continue
            else:
               line = line.split()  #saves each line as a list
               matrix.append(line) #saves lines grouped together as a list of lists
         matrices.append(matrix)
      return matrices


class HMM:
   '''
   Notes:
      MaxE modeled after Baum Welch found on stack overflow
   Args:
      iteration: an int for the number of iteraions
      observation: a string of the observation
      alphabet: a list of the alphabet in a hmm
      states: a list of the states in a hmm
      transitionMatrixList: a list of lists containing the transition matrix
      emissionMatrixList: a list of lists containing the emission matrix
   Returns:
   A matrix of transition probabilities and a matrix of emission probabilities
   '''

   def __init__(self, iteration, observation, alphabet, states, transitionMatrixList, emissionMatrixList) :
      '''
      Stores iteration, observation, alphabet, states and then builds the matrices
      '''
      self.iteration = iteration
      self.observation = observation
      self.alphabet = alphabet
      self.states = states
      self.transition = self.buildMatrix(transitionMatrixList)
      self.emission = self.buildMatrix(emissionMatrixList)
      self.observationIndex = self.convertObservation()
      self.len = len(self.observation)


   def iterator(self) :
      '''
      Iterates through calculating the forward and backword probabilities then
      Then using those to calculate Max Expectation an updating the matrices
      '''
      for i in range(self.iteration):
         fwd, full_p = self.forward()
         bwd = self.backward()
         self.maxE(fwd, bwd, full_p)



   def buildMatrix(self, matrixList) :
      '''
      creates in the numpy array of the matrix
      '''
      m = []
      #iterate through, skipping the list and first item in each following list
      for i in range(1,len(matrixList)):
         m.append(matrixList[i][1:])
      #append new lines for each row of the matrix
      m = np.array(m)
      #set alll the values to float
      matrix = m.astype(np.float)
      return matrix


   def convertObservation (self) :
      '''
      iterate through observation storing alphabet index in list
      Returns the numeric equivalent of the observation
      '''
      num = []
      for i in self.observation:
         num.append(self.alphabet.index(i))
      return num


   def forward(self):
      '''calculates the probability of the sequence'''
      observed = self.convertObservation()   #convert observed into numberic representation
      prior = 1/len(self.states)   #starting probability of that state
      
      #create empty array to hold calculations for each poisition in the observation
      fwd=np.zeros((len(self.observation),len(self.states)))   
      
      #initializes with the starting probability prior
      fwd[0]=prior*self.emission[:,observed[0]]   
     
      #Iterate through multiplying the probability for each position
      for t in range(len(self.observation)-1):   
         fwd[t+1]=np.dot(fwd[t],self.transition)*self.emission[:,observed[t+1]]
      #returns the sum
      return fwd, fwd[-1].sum()


   def backward(self):
      '''
      Calculates the backwords probability from a given observation using the
      emission and transition matrices
      '''
      obsArray = np.array(self.observationIndex) #converts the observation into an Array
      matrix = np.zeros((self.len, len(self.states))) #creates an empty matrix
      for i in range(len(self.states)): #iterates through states storing positions in matrix
         matrix[self.len - 1, i] = 1
      for i in reversed(range(self.len - 1)): #iterates through the observation in reverse
         matrix[i] = np.dot(matrix[i + 1] * self.emission[:, obsArray[i + 1]], self.transition.T)
      return matrix


   def maxE(self, fwd, bwd, obsProb):
      '''
      Calculates the max expectation for both the transition and emission
      matrices
      '''
      alphaIndex = {y: x for x, y in enumerate(self.alphabet)}
      x = np.array([alphaIndex[i] for i in self.observation])

      dimesion = (fwd * bwd) / obsProb
      k =len(self.states)
      l = len(self.alphabet) 
      
      t = np.zeros((k, k)) #build empty matrix of correct dimensions
      e = np.zeros((k, l)) #build empty matrix of correct dimensions

      for i in range(k): #optimizes the transition matrices 't'
         for j in range(self.len-1):
            t[i, :] += (fwd[j][i] * self.transition[i,:] * self.emission[:,alphaIndex[self.observation[j+1]]]* bwd[j + 1])/obsProb
         t[i, :] = t[i, :] / sum(t[i, :])

      for i in range(k): #optimizes the emission matrices 'e'
         for j in range(l):
            e[i,j] = (np.sum(dimesion[x==j,i]))/(np.sum(dimesion[:,i]))

      self.transition = t
      self.emission = e

      return t, e
   

   def printMatrices (self) :
      '''
      Prints the emission and transmission matrices
      '''
      self.iterator()
      e = self.emission.astype(str)
      t = self.transition.astype(str)
      print(" " +" ".join(self.states)) #prints transition matrix
      for i in range(len(t)):
         print(self.states[i]+" "+" ".join(t[i]))
      print('--------')
      print(" "+" ".join(self.alphabet)) #prints emission matrix
      for i in range(len(e)):
         print(self.states[i]+" "+" ".join(e[i]))


def main() :

   # read file and store as matrices
   fileReader = FileReader('')
   matrices = fileReader.readFile()

   # initialize hmm object and print the probability
   hmm = HMM(int(matrices[0][0][0]), matrices[1][0][0], matrices[2][0], matrices[3][0], matrices[4], matrices[5])

   hmm.printMatrices()


if __name__ == "__main__":
   main()
